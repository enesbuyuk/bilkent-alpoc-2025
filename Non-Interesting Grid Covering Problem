#include <bits/stdc++.h>
using namespace std;
// dinics algorithm
struct MaxFlow {
    struct Edge { int to, rev, cap; };
    int N;
    vector<vector<Edge>> G;
    vector<int> level, ptr;
    MaxFlow(int n): N(n), G(n), level(n), ptr(n) {}
    void addEdge(int u, int v, int c){
        G[u].push_back({v, (int)G[v].size(), c});
        G[v].push_back({u, (int)G[u].size()-1, 0});
    }
    bool bfs(int s, int t){
        fill(level.begin(), level.end(), -1);
        level[s] = 0;
        queue<int> q; q.push(s);
        while(!q.empty()){
            int u = q.front(); q.pop();
            for(auto &e : G[u]){
                if(level[e.to] < 0 && e.cap > 0){
                    level[e.to] = level[u] + 1;
                    q.push(e.to);
                }
            }
        }
        return level[t] >= 0;
    }
    int dfs(int u, int t, int f){
        if(u == t || f == 0) return f;
        for(int &i = ptr[u]; i < (int)G[u].size(); i++){
            auto &e = G[u][i];
            if(level[e.to] == level[u] + 1 && e.cap > 0){
                int got = dfs(e.to, t, min(f, e.cap));
                if(got){
                    e.cap -= got;
                    G[e.to][e.rev].cap += got;
                    return got;
                }
            }
        }
        return 0;
    }
    int maxflow(int s, int t){
        int flow = 0, pushed;
        while(bfs(s,t)){
            fill(ptr.begin(), ptr.end(), 0);
            while((pushed = dfs(s,t,INT_MAX)) > 0){
                flow += pushed;
            }
        }
        return flow;
    }
};
int main(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int T;
    cin >> T;
    while(T--){
        int N, M;
        cin >> N >> M;
        vector<string> G(N);
        for(int i = 0; i < N; i++) cin >> G[i];
        vector<vector<int>> idx(N, vector<int>(M, -1));
        int F = 0;
        for(int i = 0; i < N; i++) for(int j = 0; j < M; j++) if(G[i][j] == '.') idx[i][j] = F++;
        int S = F, Tt = F + 1;
        MaxFlow mf(F + 2);
        vector<int> degH(F, 0), degV(F, 0);
        int dr[4] = {0,1,0,-1}, dc[4] = {1,0,-1,0};
        for(int i = 0; i < N; i++){
            for(int j = 0; j < M; j++){
                if(idx[i][j] < 0) continue;
                int u = idx[i][j];
                for(int d = 0; d < 4; d++){
                    int ni = i + dr[d], nj = j + dc[d];
                    if(ni<0||ni>=N||nj<0||nj>=M) continue;
                    if(idx[ni][nj] < 0) continue;
                    (d%2)?degV[u]++:degH[u]++;
                }
            }
        }
        for(int u = 0; u < F; u++){
            if(degV[u] > 0) mf.addEdge(S, u, degV[u]);
            if(degH[u] > 0) mf.addEdge(u, Tt, degH[u]);
        }
        for(int i = 0; i < N; i++){
            for(int j = 0; j < M; j++){
                if(idx[i][j] < 0) continue;
                int u = idx[i][j];
                if(j+1 < M && idx[i][j+1] >= 0){
                    int v = idx[i][j+1];
                    mf.addEdge(u, v, 1);
                    mf.addEdge(v, u, 1);
                }
                if(i+1 < N && idx[i+1][j] >= 0){
                    int v = idx[i+1][j];
                    mf.addEdge(u, v, 1);
                    mf.addEdge(v, u, 1);
                }
            }
        }mf.maxflow(S, Tt);
        vector<char> vis(F + 2, 0);
        queue<int> q;
        vis[S] = 1; q.push(S);
        while(!q.empty()){
            int u = q.front(); q.pop();
            for(auto &e : mf.G[u]){
                if(!vis[e.to] && e.cap > 0){
                    vis[e.to] = 1;
                    q.push(e.to);
                }
            }
        }
        vector<vector<bool>> isV(N, vector<bool>(M, false));
        for(int i = 0; i < N; i++){
            for(int j = 0; j < M; j++){
                if(idx[i][j] >= 0){
                    isV[i][j] = vis[idx[i][j]];
                }
            }
        }
        int answer = 0;
        for(int i = 0; i < N; i++){
            for(int j = 0; j < M; j++){
                if(G[i][j] != '.') continue;
                if(isV[i][j]){
                    if(i==0 || G[i-1][j] == '#' || !isV[i-1][j]) answer++;
                } else {
                    if(j==0 || G[i][j-1] == '#' || isV[i][j-1]) answer++;
                }
            }
        }
        cout<<answer<<'\n';
    }
    return 0;
}
